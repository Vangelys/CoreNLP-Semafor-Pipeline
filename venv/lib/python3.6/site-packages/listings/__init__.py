"""This package provides file content listing features.
Features are mimics of unix's cat, tail and head. They yield lines.
"""

from __future__ import print_function

__author__ = "Michael Hooreman"
__copyright__ = "Copyright (C) 2015 - Michael Hooreman"
__license__ = "MIT"
__version__ = "1.0.4"

import time
import signal
import threading

def _isMainThread():
    """Returns True if we are in the main thread."""
    return threading.current_thread().__class__.__name__ == '_MainThread'

class _Worker:
    """Base class for all the functions backends"""

    def __init__(self, f, isFh, stripEol):
        """Constructor:
        - f: fileName of file handle
        - isFh: True if a file handle was profided
        - stripEol: True to remove the trialing new line character on every lines
        """
        self._isFh = isFh
        self._stripEol = stripEol
        if self._isFh:
            self._fh = f
        else:
            self._fh = open(f, "r")

    def __del__(self):
        """Destructor.
        Closes the file handle if a file name was provided to the constructor
        """
        if not self._isFh:
            if '_fh' in self.__dict__:  # Not the case if not yet open (e.g. file not found)
                self._fh.close()

    def _getLine(self):
        """Reads one single line of the file. Implementation depends of the child class.
        This returns a generator with raw lines.
        """
        raise NotImplementedError

    def get(self):
        """Returns all the lines.
        This returns a generator with the processed lines (e.g. end of lines stripped, etc.)
        """
        for l in self._getLine():
            if self._stripEol:
                if l[-1] == '\n':
                    l = l[:-1]
            yield l


class _CatWorker(_Worker):
    """Backend for cat"""

    def __init__(self, f, isFh, stripEol):
        """Constructor.
        - f, isFh, stripEol: see base class constructor
        """
        _Worker.__init__(self, f, isFh, stripEol)

    def _getLine(self):
        """Implementation of the base class _getLine
        All the file lines are yielded
        """
        for l in self._fh.readlines():
            yield l


class _HeadWorker(_Worker):
    """Backend for head"""

    def __init__(self, f, isFh, stripEol, n):
        """Constructor.
        - n: Number of lines to show
        - f, isFh, stripEol: see base class constructor
        """
        _Worker.__init__(self, f, isFh, stripEol)
        self._n = n

    def _getLine(self):
        """Implementation of the base class _getLine
        We yield the lines up to n and then break the loop
        """
        i = 1
        for l in self._fh.readlines():
            if i > self._n:
                break
            i += 1
            yield l


class _TailWorker(_Worker):
    """Backend for tail"""

    def __init__(self, f, isFh, stripEol, n, follow, followSleep):
        """Constructor.
        - n: Number of lines to show
        - follow: True if we must keep following new lines
        - followSleep: Number of seconds to sleep beween two refreshs in case of follow
        - f, isFh, stripEol: see base class constructor

        Follow: this will start an infinite loop which can be stopped using
        SIGINT ([Ctrl]-[C]) or SIGTERM (kill or killall's default signal).
        Please note that following will be made on the file descriptor and not
        the file name in itself. For clarity, it means that we mimic the
        follow=descriptor of tail tool (see man 1 tail)

        Please note that signal handling will only be set if we are in the main thread.
        """
        _Worker.__init__(self, f, isFh, stripEol)
        self._n = n
        self._follow = follow
        self._followSleep = followSleep
        self._stopFollow = False

    def _getLine(self):
        """Implementation of the base class _getLine
        We read all the lines and yield the last n ones. Then, we start following if needed.
        Signal handling in case of follow is done here.
        """
        i = 1

        def sigintTrap(signal, frame):
            self._stopFollow = True

        # Reads all the lines, returning only the last n
        tmp = self._fh.readlines()
        for l in tmp[-self._n:]:
            yield l
        del tmp

        # Now tails continuously if needed
        if self._follow:
            if _isMainThread():
                signal.signal(signal.SIGINT, sigintTrap)
                signal.signal(signal.SIGTERM, sigintTrap)
            while not self._stopFollow:
                w = self._fh.tell()
                l = self._fh.readline()
                if not l:
                    time.sleep(self._followSleep)
                    self._fh.seek(w)
                else:
                    yield l
            if _isMainThread():
                signal.signal(signal.SIGINT, signal.SIG_DFL)
                signal.signal(signal.SIGTERM, signal.SIG_DFL)


def cat(f, isFh=False, stripEol=True):
    """Returns an iterator yielding all the lines of a file.
    - f: fileName of file handle
    - isFh: True if a file handle was profided, defaults to False
    - stripEol: True to remove the trialing new line character on every lines, defaults to True
    """
    return _CatWorker(f, isFh, stripEol).get()


def head(f, isFh=False, stripEol=True, n=10):
    """Returns an iterator yielding the n top lines of a file.
    - f: fileName of file handle
    - isFh: True if a file handle was profided, defaults to False
    - stripEol: True to remove the trialing new line character on every lines, defaults to True
    - n: number of lines to show, defaults to 10
    """
    return _HeadWorker(f, isFh, stripEol, n).get()


def tail(f, isFh=False, stripEol=True, n=10, follow=False, followSleep=1):
    """Returns an iterator yielding the n bottom lines of a file and eventually following new lines
    - f: fileName of file handle
    - isFh: True if a file handle was profided, defaults to False
    - stripEol: True to remove the trialing new line character on every lines, defaults to True
    - n: number of lines to initially show, defaults to 10
    - follow: if True, follows new line after having shown n ones, defaults to False
    - followSleep: number of seconds to sleep between two refreshs in case of follow=True
    """
    return _TailWorker(f, isFh, stripEol, n, follow, followSleep).get()
